/*
Shuffled Binary Search In-Place Shuffle

Carl-Henrik SkŒrstedt (#Sakrac)
This is a reference implementation, something to dig up if I come up with
a need for a performance critical binary search.

The purpose of this implementation is to shuffle a sorted array in-place
such that binary search can be performed by starting with the first element
and only looking forward in memory and has closer locality between each step.

void ShuffleSortedArray(int *array, int count)
- shuffles a sorted array of integers

int ShuffledBinarySearch(int value, int *shuffled_array, int count)
- finds a value in a shuffled sorted array

int DeshuffleIndex(int index, int count)
- converts a shuffled index into a linear index

Background

Binary search is great for finding a value in a large sorted array, but cache performance
suffer from jumping between midpoint to midpoint (start at size/2, then skip to size/4 or
3*size/4 and so on). This is a partial improvement in that finding a value is lesser than
the array element results in the next array element to compare is adjacent but the greater
comparison results in a skip. A cache improvement in half the cases is still an improvement.

Reasons to shuffle

A simple improvement is to reorganize the sorted array so the array begins with the
middle value, followed by all values lower arranged in the same way and then all
values higher arranged in the same way. This means that if a match was not found in
the current iteration, if the value is lower (~50% chance) it will be the next
value in the array. If the value is higher the next value in the array will be
at the midpoint plus one.

The shuffled binary search array can be generated by first sorting values in one
array and then moving those values into another array, however this implementation
shuffles the array in-place.

For larger blocks in the array the operation is:
Move all elements in the lower half of the array down and put the pushed out value
first, then recurse into the lower half and the upper half.

For smaller blocks it is trivial to just swap a few elements around:
0 => 0
01 => 10
012 => 102
0123 => 2103
01234 => 21043
012345 => 310254
0123456 => 3102546
01234567 => 42103657

count => operations:
1, 0 => trivial
2 => swap (1,0)
3 => swap (1,0) (same as 2)
4 => swap (2,0)
5 => swap (2,0) swap(3,4) (same as 4 + swap(3,4))
6 => swap (3,0,2) swap (4,5)
7 => swap (3,0,2) swap (4,5) (same as 6)

Given the shuffled binary search array, the search function is trivial to implement.

Drawbacks
 
Insertion and deletion which is trivial with a sorted array becomes more difficult,
to the point that going back to a sorted array and, perform the operation and then
shuffle the array again is a good option.

Key/Value lookup

Reorganizing the array for cache performance only helps if multiple values fit within
a cache line so if array values are keys mapping to values the keys should reside
in one array and the values in another with matching indices for each key/value.

The returned array index will refer to the location in the shuffled array so one
option is to apply the same shuffle to both the key and the values arrays. This is
fine in most cases but the values could be more costly or awkward to move around
than the keys.

Another option is to unshuffle the index from the key lookup into a linear index,
which is a small O(log n) loop. Call DeshuffleIndex to convert a shuffled index
into a linear index.

A note on size
 
If the typical case is small enough that all values in the array fits into a cacheline
there probably is nothing measurable to gain from a binary search, or even a
shuffled binary search.
 
*/

#include <string.h>

#define MAX_SHUFFLE_COUNT_LOG2 64
void ShuffleSortedArray(int *array, int count)
{
	// each halfing splits the array in two, but only the upper half needs to go on the stack
	// the lower half is the next step of iteration
	struct { int first, count; } aStack[MAX_SHUFFLE_COUNT_LOG2];
	int stk = 0;

//	assert(count<(1<<MAX_SHUFFLE_COUNT_LOG2)); // ints can represent numbers this big

	int first = 0;		// current section of the array
	int tmp;			// temporary value for swapping elements

	while (count>1 || stk) {
		if (count<=1) {	// count 1 does not need to be shuffled
			stk--;
			first = aStack[stk].first;
			count = aStack[stk].count;
		}

		switch (count) {
			case 2:
			case 3:
				// 2 = > swap(1, 0)	3 = > swap(1, 0) (same as 2)
				tmp = array[first];
				array[first] = array[first+1];
				array[first+1] = tmp;
				count = 0;
				break;
			case 4:
				tmp = array[first];
				array[first] = array[first+2];
				array[first+2] = tmp;
				count = 0;
				break;
			case 5:
				// 5 = > swap(2, 0) swap(3, 4) (same as 4 + swap(3, 4))
				tmp = array[first];
				array[first] = array[first+2];
				array[first+2] = tmp;
				tmp = array[first+3];
				array[first+3] = array[first+4];
				array[first+4] = tmp;
				count = 0;
				break;
			case 6:
			case 7:
				// 6 = > swap(3, 0, 2) swap(4, 5); 7 = > swap(3, 0, 2) swap(4, 5) (same as 6)
				tmp = array[first];
				array[first] = array[first+3];
				array[first+3] = array[first+2];
				array[first+2] = tmp;
				tmp = array[first+4];
				array[first+4] = array[first+5];
				array[first+5] = tmp;
				count = 0;
				break;
			default:
				// count >= 8, rotate right first half elements, push second half of elements on the stack
				tmp = array[first+count/2];
				memmove(&array[first+1], &array[first], sizeof(array[0]) * (count/2));
				array[first] = tmp;
				first++;
				aStack[stk].first = first+count/2;
				aStack[stk].count = (count-1)/2;	// count>=8 => (count-1)/2>=3 so no need to check if count<=1
				stk++;
				count = count/2;
				break;
		}
	}
}

int ShuffledBinarySearch(int value, int *shuffled_array, int count)
{
	int index = 0;
	while (count) {
		int read = shuffled_array[index];
		if (value==read)
			return index;
		else if (value>read) {
			index += count/2+1;
			count = (count-1)/2;
		} else {
			index++;
			count /= 2;
		}
	}
	return -1;	// index not found
}

int DeshuffleIndex(int index, int count)
{
	// check valid range (-1 should be handled since shuffled search returns that to indicate value not found)
	if (index<0 || index>=count)
		return -1;

	int m = count/2;			// midpoint in current block
	int d = m;					// deshuffled index
	while (index) {				// index==0 means d is the deshuffled index and it is done
		if (index>m) {			// next block is upper half
			index -= m+1;		// skip current and skip to middle
			count = (count-1)/2; // size of the upper half
			d++;				// skip current
		} else {				// next block is lower half
			index--;			// skip to next
			count = m;			// size of lower half
			d -= m;				// first deshuffled index
		}
		m = count/2;			// midpoint of the current block
		d += m;					// this is the first value in block
	}
	return d;
}

